#include "SGraphNodeK2Enchanted.h"

#include "GraphEditorSettings.h"
#include "IDocumentation.h"
#include "K2Node.h"
#include "K2Node_CallFunction.h"
#include "K2Node_FunctionEntry.h"
#include "K2Node_Knot.h"
#include "SCommentBubble.h"
#include "SGraphPanel.h"
#include "SLevelOfDetailBranchNode.h"
#include "TutorialMetaData.h"
#include "BlueprintGraph/Classes/EdGraphSchema_K2.h"
#include "GraphEditor/Public/SGraphPin.h"
#include "Inspector/Enchantments.h"
#include "Misc/MessageDialog.h"
#include "Widgets/SToolTip.h"
#include "Widgets/Images/SImage.h"
#include "Widgets/Input/SCheckBox.h"
#include "Widgets/Layout/SSpacer.h"

#define LOCTEXT_NAMESPACE "BlueprintEnchantments"

FName SGraphNodeK2Enchanted::GetPinName(const UEdGraphPin * Pin)
{
	if (UEdGraphNode * GraphNode = Pin ? Pin->GetOwningNodeUnchecked( ) : nullptr)
	{
		return Pin->PinName;
	}

	return NAME_None;
}

FName SGraphNodeK2Enchanted::GetPinName(const SGraphPin & Pin)
{
	return GetPinName(Pin.GetPinObj( ));
}

FName SGraphNodeK2Enchanted::GetPinName(const TSharedRef<SGraphPin> & Pin)
{
	return GetPinName(Pin.Get( ));
}

bool SGraphNodeK2Enchanted::IsPinAdvanced(const UEdGraphPin & Pin)
{
	static const FName WorldContextPinName(TEXT("__WorldContext"));

	UEdGraphNode * GraphNode = Pin.GetOwningNodeUnchecked( );
	if (!GraphNode)
		return false;

	const FName & PinName                        = Pin.PinName;
	const bool    bIsPinBasicallyAdvanced        = Pin.bAdvancedView;
	const bool    bIsMarkedForHiding             = PinName.ToString( )[0] == HideMe_Prefix;
	bool          bIsFunctionNode                = false;
	bool          bIsValidFunctionNode           = false;
	bool          bIsWorldContextPin             = false;
	bool          bIsOptionalWorldContextPin     = false;
	bool          bIsCallerProvidingWorldContext = false;

	const UK2Node_CallFunction * CallFunctionNode = Cast<UK2Node_CallFunction>(GraphNode);
	bIsFunctionNode                               = !!CallFunctionNode;
	if (bIsFunctionNode)
	{
		const UFunction * Function = CallFunctionNode->GetTargetFunction( );
		bIsValidFunctionNode       = !!Function;

		if (bIsValidFunctionNode)
		{
			const FString & WorldContextParameterName = Function->GetMetaData(
				FBlueprintMetadata::MD_WorldContext
			);
			bIsWorldContextPin         = PinName == FName(WorldContextParameterName);
			bIsOptionalWorldContextPin =
					Function->HasMetaData(FBlueprintMetadata::MD_CallableWithoutWorldContext);

			if (const UEdGraph * CallingGraph = GraphNode->GetGraph( ))
			{
				if (const UBlueprint * OwningBlueprint = Cast<UBlueprint>(CallingGraph->GetOuter( )))
				{
					if (const UClass * Class = OwningBlueprint->GeneratedClass)
					{
						if (const UObject * CDO = Class->GetDefaultObject( ))
						{
							if (CDO->ImplementsGetWorld( ))
							{
								bIsCallerProvidingWorldContext = true;
							}
							else
							{
								for (const UEdGraphNode * Node : CallingGraph->Nodes)
								{
									if (
										Node->IsA<UK2Node_FunctionEntry>( )
										&& Node->FindPin(WorldContextPinName, EGPD_Output)
									)
									{
										bIsCallerProvidingWorldContext = true;
										break;
									}
								}
							}
						}
					}
				}
			}
		}
	}


	return
			bIsPinBasicallyAdvanced
			|| ((bIsFunctionNode && bIsValidFunctionNode && bIsWorldContextPin)
			    ? bIsOptionalWorldContextPin || bIsCallerProvidingWorldContext
			    : bIsMarkedForHiding
			);
}

bool SGraphNodeK2Enchanted::IsPinAdvanced(const TSharedRef<SGraphPin> & Pin)
{
	const UEdGraphPin * PinObj = Pin->GetPinObj( );
	if (PinObj && !PinObj->IsPendingKill( ))
	{
		return IsPinAdvanced(*PinObj);
	}

	return false;
}

bool SGraphNodeK2Enchanted::PinsColumnWillCompletelyCollapse(const UEdGraphPin & Pin) const
{
	const TArray<TSharedRef<SGraphPin>> & Column =
			Pin.Direction == EGPD_Output
			? OutputPins
			: InputPins;

	for (const TSharedRef<SGraphPin> & p : Column)
	{
		const bool bIsArgumentPin = p.Get( ).GetPinObj( ) != &Pin;
		const bool bCanHidePin    = CanHidePin(p);
		if (!bCanHidePin)
			return false;
	}

	return true;
}

bool SGraphNodeK2Enchanted::CanHidePin(const UEdGraphPin & Pin) const
{
	const bool bPinHasConnections = Pin.HasAnyConnections( );
	const bool bPinHasCustomValue = Pin.DefaultValue != Pin.AutogeneratedDefaultValue;
	const bool bIsPinAdvanced     = IsPinAdvanced(Pin);

	return
			!bPinHasCustomValue
			&& !bPinHasConnections
			&& bIsPinAdvanced;
}

bool SGraphNodeK2Enchanted::CanHidePin(const SGraphPin & Pin) const
{
	const UEdGraphPin * PinObj = Pin.GetPinObj( );
	if (PinObj && !PinObj->IsPendingKill( ))
	{
		return CanHidePin(*PinObj);
	}

	return false;
}

bool SGraphNodeK2Enchanted::CanHidePin(const TSharedRef<SGraphPin> & Pin) const
{
	return CanHidePin(Pin.Get( ));
}

bool SGraphNodeK2Enchanted::ShouldHidePin(const UEdGraphPin & Pin) const
{
	return CanHidePin(Pin) && !PinsColumnWillCompletelyCollapse(Pin);
}

bool SGraphNodeK2Enchanted::ShouldHidePin(const SGraphPin & Pin) const
{
	UEdGraphPin * PinObj = Pin.GetPinObj( );
	if (PinObj && !PinObj->IsPendingKill( ))
	{
		return ShouldHidePin(*PinObj);
	}

	return false;
}

void SGraphNodeK2Enchanted::SetIsShowingAdvancedPins(bool Value)
{
	if (UEdGraphNode * Node = GetNodeObj( ))
	{
		Node->AdvancedPinDisplay = Value ? ENodeAdvancedPins::Shown : ENodeAdvancedPins::Hidden;
	}
}

bool SGraphNodeK2Enchanted::GetIsShowingAdvancedPins( ) const
{
	if (UEdGraphNode * Node = GetNodeObj( ))
	{
		return Node->AdvancedPinDisplay == ENodeAdvancedPins::Shown ? true : false;
	}

	return true;
}

void SGraphNodeK2Enchanted::SwitchIsShowingAdvancedPins( )
{
	if (UEdGraphNode * Node = GetNodeObj( ))
	{
		Node->AdvancedPinDisplay =
				Node->AdvancedPinDisplay == ENodeAdvancedPins::Shown
				? ENodeAdvancedPins::Hidden
				: ENodeAdvancedPins::Shown;
	}
}

void SGraphNodeK2Enchanted::Construct(const FArguments & InArgs, UK2Node * InNode)
{
	this->GraphNode = InNode;

	this->SetCursor(EMouseCursor::CardinalCross);

	RegisterActiveTimer(0, FWidgetActiveTimerDelegate::CreateSP(this, &SGraphNodeK2Enchanted::DeferredConstruct));
	this->UpdateGraphNode( );
}

EActiveTimerReturnType SGraphNodeK2Enchanted::DeferredConstruct(double InCurrentTime, float InDeltaTime)
{
	if (OnDoubleClick.IsBound( ))
	{
		OriginalDoubleClickHandler = OnDoubleClick;
		OnDoubleClick.BindRaw(this, &SGraphNodeK2Enchanted::OnDoubleClicked);

		return EActiveTimerReturnType::Stop;
	}

	return EActiveTimerReturnType::Continue;
}

FReply SGraphNodeK2Enchanted::OnMouseButtonDown(const FGeometry & MyGeometry, const FPointerEvent & MouseEvent)
{
	if (!MouseEvent.IsControlDown( ))
	{
		return FReply::Unhandled( );
	}

	SGraphPanel *            Graph            = GetOwnerPanel( ).Get( );
	FGraphSelectionManager & SelectionManager = Graph->SelectionManager;
	FGraphPanelSelectionSet  NewSelectionSet, ImpureNodes;

	TArray<const UEdGraphNode *> NodesToProceed;
	TSet<const UEdGraphNode *>   ProcessedNodes;

	NodesToProceed.Push(this->GraphNode);
	do
	{
		const UEdGraphNode * Node = NodesToProceed.Pop(false);
		for (const UEdGraphPin * Pin : Node->Pins)
		{
			if (Pin->PinType.PinCategory == UEdGraphSchema_K2::PC_Exec)
			{
				for (const UEdGraphPin * LinkedTo : Pin->LinkedTo)
				{
					ImpureNodes.Add(LinkedTo->GetOwningNode( ));
				}
				continue;
			}

			for (const UEdGraphPin * LinkedTo : Pin->LinkedTo)
			{
				UEdGraphNode * Argument = LinkedTo->GetOwningNode( );
				if (!Argument->IsA<UK2Node_Knot>( ))
				{
					NewSelectionSet.Add(Argument);
					if (!ProcessedNodes.Contains(Argument) && !ImpureNodes.Contains(Argument))
					{
						NodesToProceed.Push(Argument);
					}
				}
			}
		}
		ProcessedNodes.Add(Node);
	}
	while (NodesToProceed.Num( ) > 0);

	NewSelectionSet = NewSelectionSet.Difference(ImpureNodes);
	NewSelectionSet.Remove(GraphNode);
	SelectionManager.SetSelectionSet(NewSelectionSet);

	// Always return unhandled
	return FReply::Unhandled( );
}

void SGraphNodeK2Enchanted::UpdateGraphNode( )
{
	UK2Node * K2Node = CastChecked<UK2Node>(GraphNode);

	// Node doesn't refresh enabled state on force refresh - help it
	if (UK2Node_CallFunction * CallFunctionNode = Cast<UK2Node_CallFunction>(K2Node))
	{
		if (const FEnchantments Enchantments = FEnchantments(*CallFunctionNode))
		{
			const bool bIsDevOnly       = Enchantments.Has(FEnchantments::Key_DevelopmentOnly);
			const bool bIsMarkedDevOnly = CallFunctionNode->GetDesiredEnabledState( ) ==
					ENodeEnabledState::DevelopmentOnly;
			if (!bIsMarkedDevOnly && bIsDevOnly)
			{
				CallFunctionNode->SetEnabledState(ENodeEnabledState::DevelopmentOnly, false);
			}
		}
	}

	const bool bCompactMode = K2Node->ShouldDrawCompact( );
	if (bCompactMode)
	{
		UpdateCompactNode( );
	}
	else
	{
		UpdateStandardNode( );
	}


	//	const SGraphPin& Pin = (const SGraphPin&)PinRaw;
	//	if(GetPinLabel(Pin).ToString().StartsWith(TEXT("_"),ESearchCase::CaseSensitive))
	//	{
	//		LeftNodeBox->RemoveSlot(PinRef);
	//		LeftNodeBox->InsertSlot(i)[SNew(SBorder).Content()[PinRef]];
	//	}
	//}
}

void SGraphNodeK2Enchanted::UpdateStandardNode( )
{
	// clear the default tooltip, to make room for our custom "complex" tooltip
	SetToolTip(nullptr);

	InputPins.Empty( );
	OutputPins.Empty( );

	// Reset variables that are going to be exposed, in case we are refreshing an already setup node.
	RightNodeBox.Reset( );
	LeftNodeBox.Reset( );

	//
	//             ______________________
	//            |      TITLE AREA      |
	//            +-------+------+-------+
	//            | (>) L |      | R (>) |
	//            | (>) E |      | I (>) |
	//            | (>) F |      | G (>) |
	//            | (>) T |      | H (>) |
	//            |       |      | T (>) |
	//            |_______|______|_______|
	//
	TSharedPtr<SVerticalBox> MainVerticalBox;
	SetupErrorReporting( );

	TSharedPtr<SNodeTitle> NodeTitle = SNew(SNodeTitle, GraphNode);

	// Get node icon
	IconColor                     = FLinearColor::White;
	const FSlateBrush * IconBrush = nullptr;
	if (GraphNode != NULL && GraphNode->ShowPaletteIconOnNode( ))
	{
		IconBrush = GraphNode->GetIconAndTint(IconColor).GetOptionalIcon( );
	}

	TSharedRef<SOverlay> DefaultTitleAreaWidget =
			SNew(SOverlay)
			+ SOverlay::Slot( )
			[
				SNew(SImage)
			.Image(FEditorStyle::GetBrush("Graph.Node.TitleGloss"))
		.ColorAndOpacity(this, &SGraphNode::GetNodeTitleIconColor)
			]
			+ SOverlay::Slot( )
			  .HAlign(HAlign_Fill)
			  .VAlign(VAlign_Center)
			[
				SNew(SHorizontalBox)
				+ SHorizontalBox::Slot( )
				.HAlign(HAlign_Fill)
				[
					SNew(SBorder)
			.BorderImage(FEditorStyle::GetBrush("Graph.Node.ColorSpill"))
		// The extra margin on the right
		// is for making the color spill stretch well past the node title
		.Padding(FMargin(10, 5, 30, 3))
		.BorderBackgroundColor(this, &SGraphNode::GetNodeTitleColor)
					[
						SNew(SHorizontalBox)
						+ SHorizontalBox::Slot( )
						  .VAlign(VAlign_Top)
						  .Padding(FMargin(0.f, 0.f, 4.f, 0.f))
						  .AutoWidth( )
						[
							SNew(SImage)
						.Image(IconBrush)
						.ColorAndOpacity(this, &SGraphNode::GetNodeTitleIconColor)
						]
						+ SHorizontalBox::Slot( )
						[
							SNew(SVerticalBox)
							+ SVerticalBox::Slot( )
							.AutoHeight( )
							[
								CreateTitleWidget(NodeTitle)
							]
							+ SVerticalBox::Slot( )
							.AutoHeight( )
							[
								NodeTitle.ToSharedRef( )
							]
						]
					]
				]
				+ SHorizontalBox::Slot( )
				  .HAlign(HAlign_Right)
				  .VAlign(VAlign_Center)
				  .Padding(0, 0, 5, 0)
				  .AutoWidth( )
				[
					CreateTitleRightWidget( )
				]
			]
			+ SOverlay::Slot( )
			.VAlign(VAlign_Top)
			[
				SNew(SBorder)
			.Visibility(EVisibility::HitTestInvisible)
			.BorderImage(FEditorStyle::GetBrush("Graph.Node.TitleHighlight"))
			.BorderBackgroundColor(this, &SGraphNode::GetNodeTitleIconColor)
				[
					SNew(SSpacer)
					.Size(FVector2D(20, 20))
				]
			];

	SetDefaultTitleAreaWidget(DefaultTitleAreaWidget);

	TSharedRef<SWidget> TitleAreaWidget =
			SNew(SLevelOfDetailBranchNode)
		.UseLowDetailSlot(this, &SGraphNodeK2Enchanted::UseLowDetailNodeTitles)
		.LowDetail( )
			[
				SNew(SBorder)
			.BorderImage(FEditorStyle::GetBrush("Graph.Node.ColorSpill"))
			.Padding(
					             FMargin(75.0f, 22.0f)
				             ) // Saving enough space for a 'typical' title so the transition isn't quite so abrupt
		.BorderBackgroundColor(this, &SGraphNode::GetNodeTitleColor)
			]
			.HighDetail( )
			[
				DefaultTitleAreaWidget
			];


	if (!SWidget::GetToolTip( ).IsValid( ))
	{
		TSharedRef<SToolTip> DefaultToolTip = IDocumentation::Get( )->CreateToolTip(
			TAttribute<FText>(this, &SGraphNode::GetNodeTooltip),
			NULL,
			GraphNode->GetDocumentationLink( ),
			GraphNode->GetDocumentationExcerptName( )
		);
		SetToolTip(DefaultToolTip);
	}

	// Setup a meta tag for this node
	FGraphNodeMetaData TagMeta(TEXT("Graphnode"));
	PopulateMetaTag(&TagMeta);

	TSharedPtr<SVerticalBox> InnerVerticalBox;
	this->ContentScale.Bind(this, &SGraphNode::GetContentScale);


	InnerVerticalBox = SNew(SVerticalBox)
			+ SVerticalBox::Slot( )
			  .AutoHeight( )
			  .HAlign(HAlign_Fill)
			  .VAlign(VAlign_Top)
			  .Padding(Settings->GetNonPinNodeBodyPadding( ))
			[
				TitleAreaWidget
			]

			+ SVerticalBox::Slot( )
			  .AutoHeight( )
			  .HAlign(HAlign_Fill)
			  .VAlign(VAlign_Top)
			[
				CreateNodeContentArea( )
			];

	TSharedPtr<SWidget> EnabledStateWidget = GetEnabledStateWidget( );
	if (EnabledStateWidget.IsValid( ))
	{
		InnerVerticalBox->AddSlot( )
		                .AutoHeight( )
		                .HAlign(HAlign_Fill)
		                .VAlign(VAlign_Top)
		                .Padding(FMargin(2, 0))
		[
			EnabledStateWidget.ToSharedRef( )
		];
	}

	InnerVerticalBox->AddSlot( )
	                .AutoHeight( )
	                .Padding(Settings->GetNonPinNodeBodyPadding( ))
	[
		ErrorReporting->AsWidget( )
	];



	this->GetOrAddSlot(ENodeZone::Center)
	    .HAlign(HAlign_Center)
	    .VAlign(VAlign_Center)
	[
		SAssignNew(MainVerticalBox, SVerticalBox)
		+ SVerticalBox::Slot( )
		.AutoHeight( )
		[
			SNew(SOverlay)
			.AddMetaData<FGraphNodeMetaData>(TagMeta)
			+ SOverlay::Slot( )
			.Padding(Settings->GetNonPinNodeBodyPadding( ))
			[
				SNew(SImage)
				.Image(GetNodeBodyBrush( ))
				.ColorAndOpacity(this, &SGraphNode::GetNodeBodyColor)
			]
			+ SOverlay::Slot( )
			[
				InnerVerticalBox.ToSharedRef( )
			]
		]
	];

	bool SupportsBubble = true;
	if (GraphNode != nullptr)
	{
		SupportsBubble = GraphNode->SupportsCommentBubble( );
	}

	if (SupportsBubble)
	{
		// Create comment bubble
		TSharedPtr<SCommentBubble> CommentBubble;
		const FSlateColor          CommentColor = GetDefault<UGraphEditorSettings>( )->
				DefaultCommentNodeTitleColor;

		SAssignNew(CommentBubble, SCommentBubble)
			.GraphNode(GraphNode)
			.Text(this, &SGraphNode::GetNodeComment)
			.OnTextCommitted(this, &SGraphNode::OnCommentTextCommitted)
			.OnToggled(this, &SGraphNode::OnCommentBubbleToggled)
			.ColorAndOpacity(CommentColor)
			.AllowPinning(true)
			.EnableTitleBarBubble(true)
			.EnableBubbleCtrls(true)
			.GraphLOD(this, &SGraphNode::GetCurrentLOD)
			.IsGraphNodeHovered(this, &SGraphNode::IsHovered);

		GetOrAddSlot(ENodeZone::TopCenter)
				.SlotOffset(TAttribute<FVector2D>(CommentBubble.Get( ), &SCommentBubble::GetOffset))
				.SlotSize(TAttribute<FVector2D>(CommentBubble.Get( ), &SCommentBubble::GetSize))
				.AllowScaling(TAttribute<bool>(CommentBubble.Get( ), &SCommentBubble::IsScalingAllowed))
				.VAlign(VAlign_Top)
				[
					CommentBubble.ToSharedRef( )
				];
	}

	CreateBelowWidgetControls(MainVerticalBox);
	CreatePinWidgets( );
	CreateInputSideAddButton(LeftNodeBox);
	CreateOutputSideAddButton(RightNodeBox);
	CreateBelowPinControls(InnerVerticalBox);
	CreateAdvancedViewArrow(InnerVerticalBox);
}

void SGraphNodeK2Enchanted::CreateAdvancedViewArrow(TSharedPtr<SVerticalBox> MainBox)
{
	const bool bHidePins = OwnerGraphPanelPtr.IsValid( ) && (
		OwnerGraphPanelPtr.Pin( )->GetPinVisibility( ) !=
		SGraphEditor::Pin_Show);
	if (!bHidePins && GraphNode && MainBox.IsValid( ))
	{
		MainBox->AddSlot( )
		       .AutoHeight( )
		       .HAlign(HAlign_Fill)
		       .VAlign(VAlign_Top)
		       .Padding(3, 0, 3, 3)
		[
			SNew(SCheckBox)
// @formatter:off
			.Visibility_Lambda
			(
				[this]( )-> EVisibility
				{
					return HaveAnyAdvancedPins()
						       ? EVisibility::Visible
						       : EVisibility::Collapsed;
				}
			)
			.OnCheckStateChanged_Lambda
			(
				[this](const ECheckBoxState NewCheckedState)-> void 
				{
					SwitchIsShowingAdvancedPins();
				}
			)
			.IsChecked_Lambda
			(
				[this]( )-> ECheckBoxState 
				{
					return GetIsShowingAdvancedPins()
						       ? ECheckBoxState::Unchecked
						       : ECheckBoxState::Checked;
				}
			)
// @formatter:on
			.Cursor(EMouseCursor::Default)
			.Style(FEditorStyle::Get( ), "Graph.Node.AdvancedView")
			[
				SNew(SHorizontalBox)
				+ SHorizontalBox::Slot( )
				  .VAlign(VAlign_Center)
				  .HAlign(HAlign_Center)
				[
					SNew(SImage)
					.Image_Lambda(
						[this]( )-> const FSlateBrush*
						{
							return FEditorStyle::GetBrush(
								!GetIsShowingAdvancedPins( )
								? TEXT("Kismet.TitleBarEditor.ArrowDown")
								: TEXT("Kismet.TitleBarEditor.ArrowUp")
							);
						}
					)
				]
			]
		];
	}
}

void SGraphNodeK2Enchanted::AddPin(const TSharedRef<SGraphPin> & PinToAdd)
{
	PinToAdd->SetOwner(SharedThis(this));

	const UEdGraphPin * PinObj             = PinToAdd->GetPinObj( );
	const bool          bAdvancedParameter =
			PinObj != nullptr
			&& (PinObj->bAdvancedView || IsPinAdvanced(PinToAdd));
	if (bAdvancedParameter)
	{
		const SGraphPin &                        Pin    = PinToAdd.Get( );
		const TAttribute<EVisibility>::FGetter & Getter =
				TAttribute<EVisibility>::FGetter::CreateLambda
		// @formatter:off
			(
				[this, &Pin]( )-> EVisibility
				{
					return !GetIsShowingAdvancedPins() && ShouldHidePin(Pin)
						? EVisibility::Collapsed
						: EVisibility::Visible;
				}
			);
		// @formatter:on
		PinToAdd->SetVisibility(TAttribute<EVisibility>::Create(Getter));
	}

	if (PinToAdd->GetDirection( ) == EEdGraphPinDirection::EGPD_Input)
	{
		LeftNodeBox->AddSlot( )
		           .AutoHeight( )
		           .HAlign(HAlign_Left)
		           .VAlign(VAlign_Center)
		           .Padding(Settings->GetInputPinPadding( ))
		[
			PinToAdd
		];
		InputPins.Add(PinToAdd);
	}
	else // Direction == EEdGraphPinDirection::EGPD_Output
	{
		RightNodeBox->AddSlot( )
		            .AutoHeight( )
		            .HAlign(HAlign_Right)
		            .VAlign(VAlign_Center)
		            .Padding(Settings->GetOutputPinPadding( ))
		[
			PinToAdd
		];
		OutputPins.Add(PinToAdd);
	}
}

void SGraphNodeK2Enchanted::OnDoubleClicked(UEdGraphNode * Node) const
{
	if (const UK2Node_CallFunction * CallFunctionNode = Cast<UK2Node_CallFunction>(Node))
	{
		const UFunction * TargetFunction  = CallFunctionNode->GetTargetFunction( );
		const bool        bNativeFunction = (TargetFunction != nullptr) && (TargetFunction->IsNative( ));
		if (bNativeFunction)
		{
			const EAppReturnType::Type bProceed = FMessageDialog::Open(
				EAppMsgType::YesNo,
				LOCTEXT("Open native code dialog", "Das scheise ist CPP. Proceed?")
			);
			if (bProceed != EAppReturnType::Yes)
				return;
		}
	}

	assumeChecked(OriginalDoubleClickHandler.IsBound());
	OriginalDoubleClickHandler.Execute(Node);
}

bool SGraphNodeK2Enchanted::HaveAnyAdvancedPins( ) const
{
	for (const TSharedRef<SGraphPin> & Pin : InputPins)
	{
		if (IsPinAdvanced(Pin))
			return true;
	}
	for (const TSharedRef<SGraphPin> & Pin : OutputPins)
	{
		if (IsPinAdvanced(Pin))
			return true;
	}

	return false;
}

bool SGraphNodeK2Enchanted::HaveAnyRegularPins( ) const
{
	for (const TSharedRef<SGraphPin> & Pin : InputPins)
	{
		if (!IsPinAdvanced(Pin))
			return true;
	}
	for (const TSharedRef<SGraphPin> & Pin : OutputPins)
	{
		if (!IsPinAdvanced(Pin))
			return true;
	}

	return false;
}

bool SGraphNodeK2Enchanted::HaveBothRegularAndAdvancedPins( ) const
{
	bool bHavePinsToHide = false;
	bool bHavePinsToView = false;

	for (const TSharedRef<SGraphPin> & Pin : InputPins)
	{
		if (IsPinAdvanced(Pin))
			bHavePinsToHide = true;
		else
			bHavePinsToView = true;

		if (bHavePinsToHide && bHavePinsToView)
			return true;
	}
	for (const TSharedRef<SGraphPin> & Pin : OutputPins)
	{
		if (IsPinAdvanced(Pin))
			bHavePinsToHide = true;
		else
			bHavePinsToView = true;

		if (bHavePinsToHide && bHavePinsToView)
			return true;
	}

	return false;
}
